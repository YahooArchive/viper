/*
 * Copyright 2016, Yahoo Inc.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

package com.yahoo.viper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.yahoo.viper.util.Utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.Socket;
import java.util.concurrent.atomic.AtomicReference;

/**
 * This task is used to check the health of a particular host.
 */
public class CheckTask implements Runnable {

    final static Logger logger = LoggerFactory.getLogger(CheckTask.class);

    final HostMonitor monitor;
    private HostInfo hinfo;

    // If not null, holds the thread currently executing the task.
    // The atomic reference is used to avoid having the same task checking the host.
    private AtomicReference<Thread> executingThread = new AtomicReference<>();

    /**
     * Constructs a task for use by an executor. This task will check the specified host.
     * If this task object is already being executed from a previous submit to the executor service,
     * this task will exit quietly.
     *
     * @param monitor Non-null string that is displayed with all log entries from this instance.
     * @param hinfo   Non-null host information to check.
     */
    CheckTask(HostMonitor monitor, HostInfo hinfo) {
        this.monitor = monitor;
        this.hinfo = hinfo;
    }

    /**
     * Returns true if the host is currently being checked.
     *
     * @return true if the host is currnetly being checked.
     */
    public boolean isChecking() {
        return executingThread.get() != null;
    }

    /**
     * If the task is currently being executed, interrupt the thread executing it.
     */
    public void cancel() {
        // Capture the executing thread value to avoid a race condition
        Thread t = executingThread.get();
        if (t != null) {
            t.interrupt();
        }
    }

    /**
     * The host-checking logic. It is possible for this method to hang because of problems with the host.
     */
    public void run() {
        // Capture the thread so that it can be interrupted by cancel()
        if (!executingThread.compareAndSet(null, Thread.currentThread())) {
            // Don't check if already checking
            return;
        }
        try {
            doRun();
        } catch (Throwable e) {
            hinfo.logger.error(e.getMessage(), e);
        } finally {
            // Indicate that the check is finished
            executingThread.set(null);
        }
    }

    private void doRun() throws Exception {
        InputStream in = null;
        OutputStream out = null;
        HttpURLConnection http = null;
        try {
            // Start checking
            hinfo.lastCheck = Utils.getActualTime();

            if (hinfo.url == null) {
                // Check host and port
                Socket socket = new Socket();
                socket.connect(hinfo.socketAddress, monitor.checkPeriodMs);
                in = socket.getInputStream();
                out = socket.getOutputStream();
                in.read();
            } else {
                // Check URL
                http = (HttpURLConnection) hinfo.url.openConnection();
                http.setConnectTimeout(monitor.checkPeriodMs);
                int status = http.getResponseCode();
                if (status != 200) {
                    throw new IOException(String.format("returning status %d", status));
                }
            }

            // Success
            hinfo.lastLive = Utils.getActualTime();
            if (!hinfo.live) {
                hinfo.logger.info(String.format("[%s] %s is now live", monitor.name,
                        hinfo.url == null ? hinfo.socketAddress : hinfo.url));
                hinfo.failedChecks = 0;
                hinfo.live = true;
            }
        } catch (Throwable e) {
            // All exceptions encountered by the checker should just be info.
            // Warnings and errors are generated by the HostMonitor background thread.
            if (++hinfo.failedChecks > monitor.retries) {
                hinfo.live = false;
            }
            logInfo(true, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (Exception e) {
                    logInfo(false, e);
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (Exception e) {
                    logInfo(false, e);
                }
            }
            if (http != null) {
                http.disconnect();
            }
        }
    }

    private void logInfo(boolean showRetries, Throwable e) {
        if (monitor.showFullStackTraces) {
            hinfo.logger.error("Failed check for " + hinfo, e);
        } else {
            int r = Math.max(0, monitor.retries + 1 - hinfo.failedChecks);
            String s = showRetries && r > 0 ? "(" + r + " more retries)" : "";
            hinfo.logger.info(String.format("[%s] %s: %s[%s] %s",
                    monitor.name, hinfo.url == null ? hinfo.socketAddress : hinfo.url,
                    e.getClass().getName(),
                    e.getMessage(), s));
        }
    }
}
